--SQL SHORTS

SELECT * FROM DEPARTMENTS;

SELECT DEPARTMENT_NAME FROM DEPARTMENTS;

SELECT DEPARTMENT_NAME , DEPARTMENT_ID
FROM DEPARTMENTS;

SELECT DEPARTMENT_NAME , DEPARTMENT_ID 
FROM DEPARTMENTS;

SELECT *
FROM DEPARTMENTS , EMPLOYEES;

SELECT EMPLOYEES.EMPLOYEE_ID, DEPARTMENTS.DEPARTMENT_ID
FROM DEPARTMENTS , EMPLOYEES;

/*
DISTINCT keyword : it displays the result without the duplicates
*/

SELECT DISTINCT DEPARTMENT_ID
FROM DEPARTMENTS;

SELECT DISTINCT SALARY
FROM EMPLOYEES;

SELECT DISTINCT MAX_SALARY FROM JOBS;

---WHERE CLAUSE, IN AND BETWEEN STATEMENTS

SELECT *
FROM EMPLOYEES
WHERE SALARY < 5000;

SELECT *
FROM EMPLOYEES
WHERE SALARY < 5000 AND MANAGER_ID = 114;

/*
BETWEEN STATEMENT: used for specifyting the range of the condition
                                            value between low and high
*/

SELECT *
FROM DEPARTMENTS
WHERE LOCATION_ID BETWEEN 1800 AND 2400;

SELECT *
FROM EMPLOYEES
WHERE SALARY BETWEEN 3500 AND 5000;


/*
IN STATEMENT: used for specifying the range of the condtion
*/

SELECT *
FROM EMPLOYEES
WHERE DEPARTMENT_ID IN (60 , 110 , 30);

SELECT *
FROM COUNTRIES
WHERE REGION_ID IN (1 , 4);


---ORDER BY STATEMENT: used for sorting the result

SELECT *
FROM COUNTRIES
ORDER BY REGION_ID;---by default sorts in ascending order

SELECT *
FROM COUNTRIES
WHERE REGION_ID < 5
ORDER BY REGION_ID ASC;

SELECT *
FROM COUNTRIES
ORDER BY REGION_ID DESC;


---LIKE STATEMENT: partial search (WildCard)

--starts with: 'Chars%'
SELECT COUNT(COUNTRY_NAME)
FROM COUNTRIES
WHERE COUNTRY_NAME LIKE 'Au%';

--ends with: '%chars'
SELECT COUNT(COUNTRY_NAME)
FROM COUNTRIES
WHERE COUNTRY_NAME LIKE '%a';

--starts with & ends with:
SELECT *
FROM COUNTRIES
WHERE COUNTRY_NAME LIKE 'A%' AND COUNTRY_NAME LIKE '%a';

---contains: '%chars%'
SELECT COUNTRY_NAME
FROM COUNTRIES
WHERE COUNTRY_NAME LIKE '%b%';


---TEXT FUNCTIONS
--ONLY USED TO DISPLAY DATA, DOES NOT MPDIFY THE TABLE

--CONCATENATION OPERATOR ||:
SELECT EMAIL || '@gmail.com' FROM EMPLOYEES;

SELECT FIRST_NAME || ' ' || LAST_NAME FROM EMPLOYEES;

---CONCAT(VALUE1 , VALUE2)
SELECT CONCAT(EMAIL , '@gmail.com')  FROM EMPLOYEES;

SELECT CONCAT(   CONCAT(FIRST_NAME , ' ' )   ,     LAST_NAME)     FROM EMPLOYEES;

---UPPER(VALUE)
SELECT UPPER(FIRST_NAME) FROM EMPLOYEES;

--LOWER(VALUE)
SELECT LOWER(FIRST_NAME) FROM EMPLOYEES;

--INITCAP(VALUE) - FIRST LETTER CAPITAL, REST LOWER
SELECT INITCAP(EMAIL) FROM EMPLOYEES;

--LENGTH(VALUE)
SELECT FIRST_NAME , LENGTH(FIRST_NAME) FROM EMPLOYEES;

--REPLACE(COLUMN_NAME , OLD_VALUE, NEW_VALUE)
SELECT FIRST_NAME FROM EMPLOYEES;
SELECT REPLACE(FIRST_NAME , 'e' , 'E')    FROM EMPLOYEES;


--SUBSTR(COLUMN_NAME , BEG_INDEX , END_INDEX)
SELECT FIRST_NAME , SUBSTR(FIRST_NAME , 0 , 1)     FROM EMPLOYEES;

SELECT SUBSTR(FIRST_NAME , 0, 1)  ||   SUBSTR(LAST_NAME , 0 , 1)   FROM EMPLOYEES;

--TRIM(VALUE): REMOVES WHITESPACE
SELECT TRIM(CONCAT('             ' , FIRST_NAME)) FROM EMPLOYEES;


---AGGREGATE FUNCTIONS and COUNT() & ROUND()

SELECT MIN(LOCATION_ID) FROM DEPARTMENTS;---1400

SELECT *
FROM DEPARTMENTS
WHERE LOCATION_ID = (
                                -- RETURNS 1400
                            SELECT MIN(LOCATION_ID) 
                            FROM DEPARTMENTS
                );
                
SELECT MAX(LOCATION_ID) FROM DEPARTMENTS; 

SELECT * 
FROM DEPARTMENTS 
WHERE LOCATION_ID = (
                                SELECT MAX(LOCATION_ID)
                                FROM DEPARTMENTS
                );              
                

SELECT MAX(SALARY) FROM EMPLOYEES;

SELECT * 
FROM EMPLOYEES
WHERE SALARY = (
                        SELECT MAX(SALARY)
                        FROM EMPLOYEES
            );
            
            
SELECT *
FROM EMPLOYEES
WHERE SALARY = (
                SELECT MIN(SALARY)
                FROM EMPLOYEES
                );
                
                
SELECT ROUND(AVG(SALARY), 3) FROM EMPLOYEES;


SELECT SUM(SALARY) FROM EMPLOYEES; --- RETURNS SUM OF THE VALUES


SELECT * FROM EMPLOYEES;

SELECT COUNT(*) FROM EMPLOYEES 
WHERE MANAGER_ID = 100;

SELECT COUNT(*) FROM EMPLOYEES WHERE SALARY < 10000;



---GROUP BY & HAVING
--GROUP BY: DIVIDES ROWS INTO GROUPS

SELECT JOB_ID , COUNT(*)
FROM EMPLOYEES
GROUP BY JOB_ID;


SELECT JOB_ID , MAX(SALARY) 
FROM EMPLOYEES
GROUP BY JOB_ID;

SELECT JOB_ID , AVG(SALARY)
FROM EMPLOYEES
GROUP BY JOB_ID;

SELECT JOB_ID , SUM(SALARY)
FROM EMPLOYEES
GROUP BY JOB_ID;

--HAVING:

SELECT JOB_ID , COUNT(*) , MAX(SALARY)
FROM EMPLOYEES
GROUP BY JOB_ID
HAVING MAX(SALARY) > 2000;


SELECT JOB_ID , COUNT(*) ,AVG(SALARY)
FROM EMPLOYEES
GROUP BY JOB_ID
HAVING AVG(SALARY) > 6000;


SELECT JOB_ID , COUNT(*) ,MIN(SALARY)
FROM EMPLOYEES
GROUP BY JOB_ID
HAVING MIN(SALARY) > 5000;


---ALIASES: TABLE & COLUMN

---COLUMN ALIASES
SELECT FIRST_NAME AS "GIVEN NAME" 
FROM EMPLOYEES;

SELECT FIRST_NAME || ' ' || LAST_NAME AS "FULL NAME" 
FROM EMPLOYEES;

SELECT EMAIL || '@gmail.com' AS "EMAIL ADDRESS" 
FROM EMPLOYEES;

--TABLE ALIASES
SELECT * FROM EMPLOYEES , JOB_HISTORY;
SELECT e.EMPLOYEE_ID , jh.JOB_ID   FROM   EMPLOYEES e,    JOB_HISTORY jh;


---VIEWS: VIRTUAL TABLES (DO NOT STORE DATA) - they store queries to retreive other table'S DATA
--CREATE VIEW:
            --CREATE VIEW VIEW_NAME AS STATEMENT;
SELECT * FROM EMPLOYEES;

SELECT    LAST_NAME || ' ' || FIRST_NAME   AS  FULLNAME  FROM    EMPLOYEES;

CREATE VIEW EMPLOYEE_INFO AS SELECT    LAST_NAME || ' ' || FIRST_NAME   AS  FULLNAME  FROM    EMPLOYEES;

SELECT * FROM EMPLOYEE_INFO;---EMPLOYEE_INFO IS POINTING TO EMPLOYEES TABLE (DOES NOT STORE DATA BY ITSELF)

--REPLACE VIEW: 
            -- CREATE OR REPLACE VIEW VIEWNAME AS STATEMENT;

SELECT    LAST_NAME || ' ' || FIRST_NAME   AS  FULLNAME , 
LOWER(EMAIL || '@gmail.com')   AS   EMAIL
FROM    EMPLOYEES;

CREATE OR REPLACE VIEW EMPLOYEE_INFO AS SELECT    LAST_NAME || ' ' || FIRST_NAME   AS  FULLNAME , 
LOWER(EMAIL || '@gmail.com')   AS   EMAIL
FROM    EMPLOYEES;

SELECT * FROM EMPLOYEE_INFO;


--DROP VIEW: DELETES THE VIEW
        -- DROP VIEW VIEWNAME;
        
DROP VIEW EMPLOYEE_INFO;        


---TABLES: CREATE , INSERT , UPDATE , DELETE
/*
CREATE TABLE:
            SYNTAX:
            
                    create table Name(
                    columnName1  DataType  Constraint,
                    ColumnName2  DataType  Constraint
                    );
                    
                    Constraint is not mandatory
                    
INSERT: 
            SYNTAX:
            
            Insert Into TableName (Column1 , column2, ...)
            Values (value1, value2...);
            
            
UPDATE:
            SYNTAX:
            
            UPDATE TableName
            SET ColumnName = Value
            WHERE Condition;
            
            
DELETE:
            SYNTAX:
            
            DELETE FROM Table_name
            WHERE condition;
            
COMMIT:
            COMMIT;
            COMMIT WORK;
            
            
ALTER: 
            ADD COLUMN:
                        SYNTAX:
                                ALTER TABLE TALBE_NAME ADD COLUMN_NAME DATATYPE;
                                
             RENAME COLUMN:
                        SYNTAX:
                                ALTER TABLE TABLENAME RENAME COLUMN COLUMN_NAME TO NEW_COLUMN_NAME;
                                
              DROP COLUMN:
                        SYNTAX:
                                ALTER TABLE TABLE_NAME DROP COLUMN COLUMN_NAME
                                
               RENAME TABLE:
                        SYNTAX:
                                ALTER TABLE TABLE_NAME RENAME TO NEW_TABLE_NAME
                                

DROP TABLE:
                        SYNTAX:
                                DROP TABLE TABLE_NAME
                    
                    
TRUNCATE: REMOVES ALL THE DATA FROM A TABLE (BUT DOES NOT DROP THE TABLE ITSELF)
                        SYNTAX:
                                TRUNCATE TABLE TABLE_NAME
                    
*/


CREATE TABLE ADDRESS123(
ADDRESS_ID INTEGER PRIMARY KEY,
ADDRESS  VARCHAR (50) NOT NULL,---50 IS THE LIMIT FOR CHARS NUMBER
PHONE INTEGER
);


INSERT INTO ADDRESS123 (ADDRESS_ID , ADDRESS, PHONE)
VALUES (10, 'Lee Highway', 123456);

INSERT INTO ADDRESS123 (ADDRESS_ID , ADDRESS, PHONE)
VALUES (10, 'Lee Highway', 123456);---ERROR: PRIMARY KEY CANNOT BE DUPLICATED


INSERT INTO ADDRESS123 (ADDRESS_ID , ADDRESS, PHONE)
VALUES (11, 'Balltown Rd', 98765);


CREATE TABLE CUSTOMER3 (
CUSTOMER_ID INTEGER PRIMARY KEY,
FIRST_NAME  VARCHAR(30) NULL,
ADDRESS_ID INTEGER REFERENCES ADDRESS123(ADDRESS_ID)
);

INSERT INTO CUSTOMER3 (CUSTOMER_ID, FIRST_NAME, ADDRESS_ID)
VALUES (1 , 'Muhtar' , 11); ---FOREIGN KEY INFO MUST MATCH WITH PRIMARY KEY

INSERT INTO CUSTOMER3 (CUSTOMER_ID , FIRST_NAME, ADDRESS_ID)
VALUES (2 , 'John' , 10);


UPDATE CUSTOMER3 
SET CUSTOMER_ID = 3
WHERE ADDRESS_ID = 10;


DELETE FROM CUSTOMER3 
WHERE CUSTOMER_ID = 3 AND ADDRESS_ID = 10;



SELECT * FROM ADDRESS123;

SELECT * FROM CUSTOMER3;

COMMIT;
COMMIT WORK; -- IS DONE AT THE VERY END


ALTER TABLE CUSTOMER3 ADD LAST_NAME VARCHAR(20);


ALTER TABLE CUSTOMER3 RENAME COLUMN LAST_NAME TO CITY;

UPDATE CUSTOMER3 
SET CITY = 'Miami'
WHERE CUSTOMER_ID = 1;

UPDATE CUSTOMER3
SET CITY = 'Colorado'
WHERE ADDRESS_ID = 10;

ALTER TABLE CUSTOMER3
DROP COLUMN CITY;

ALTER TABLE CUSTOMER3 
RENAME TO SHOPPERS1;

SELECT * FROM SHOPPERS1;

SELECT * FROM SHOPPERS1;
DROP TABLE SHOPPERS;

SELECT * FROM SHOPPERS1;
TRUNCATE TABLE SHOPPERS1;

COMMIT;


---USE OF FOREIGN KEY AND PRIMARY KEY IN TABLE STRUCTURES
CREATE TABLE CLASSMATES1 (
STUDENT_ID INTEGER PRIMARY KEY,  ---MUST BE UNIQUE AND CANNOT BE NULL
"FIRST NAME" VARCHAR(30),
"LAST NAME" VARCHAR(30)
);

SELECT * FROM CLASSMATES1;

CREATE TABLE COWORKERS123 (
EMPLOYEE_ID INTEGER PRIMARY KEY, ---MUST BE UNIQUE AND CANNOT BE NULL
"FIRST NAME" VARCHAR(30),
"LAST NAME" VARCHAR(30),
PERSONNEL_ID INTEGER REFERENCES CLASSMATES1(STUDENT_ID)
--- FOREIGN KEY,  DATA NEEDS TO BE MATCHED WITH THE REFERENCED PRIMARY KEY, CAN BE DUPLICATED, CAN BE NULL
);

---INSERT INTO COWORKERS123 VALUES(1 , 'John' , 'Eric', 2); CANNOT INSERT AS PRIMARY KEY STUDENT_ID DOES NOT HAVE VALUES YET
--WE CAN ONLY INSERT NULL STUDENT_ID FOR NOW
INSERT INTO COWORKERS123 VALUES(1 , 'John' , 'Eric', NULL);

SELECT * FROM COWORKERS123;

INSERT INTO CLASSMATES1 VALUES (1 , 'Aaron' , 'Daniel');

SELECT * FROM CLASSMATES1;

INSERT INTO COWORKERS123 VALUES(2, 'Jimmy' , 'Rose', 1);---WE HAVE STUDENT_ID AS 1 IN CLASSMATES1 TABLE. WE CAN ONLY GIVE 1

---INSERT INTO COWORKERS VALUES (3, 'Ahmet' , 'Mamat' , 2); 
--FOREIGN KEY DATA IS NOT MATCHING WITH THE REFERENCED PRIMARY KEY'S DATA

SELECT * FROM CLASSMATES1;

UPDATE CLASSMATES1 
SET STUDENT_ID = 4
WHERE STUDENT_ID = 1;
--CANNOT MAKE ANY CHANGES TO PRIMARY KEY, WE NEED TO CHANGE THE FOREIGN IT IS BEING REFERENCED TO
ALTER TABLE CLASSMATES1 DROP COLUMN STUDENT_ID;
DROP TABLE CLASSMATES1;

---WE NEED TO DROP FOREIGN KEY FIRST
ALTER TABLE COWORKERS123 DROP COLUMN PERSONNEL_ID;

---NOW WE CAN MAKE CHANGES TO PRIMARY KEY
UPDATE CLASSMATES1 
SET STUDENT_ID = 4
WHERE STUDENT_ID = 1;

SELECT * FROM CLASSMATES1;
ALTER TABLE CLASSMATES1 DROP COLUMN STUDENT_ID;
TRUNCATE TABLE CLASSMATES1;


---INNER JOIN: returns only matching data from 2 tables (primary key and foreign key relationship)

CREATE TABLE ADDRESS3(
ADDRESS_ID INTEGER PRIMARY KEY,
ADDRESS VARCHAR(50) ,
PHONE INTEGER
);

CREATE TABLE CUSTOMER (
CUSTOMER_ID INTEGER PRIMARY KEY,
FIRST_NAME VARCHAR(20) NOT NULL,
LAST_NAME VARCHAR(20) NOT NULL,
ADDRESS_ID INTEGER REFERENCES ADDRESS3(ADDRESS_ID)
);

INSERT INTO ADDRESS3 VALUES (11 , '900 Santiago', 16571220);

INSERT INTO CUSTOMER VALUES (5, 'Elizabeth', 'Brown', NULL);

SELECT * FROM CUSTOMER;

SELECT * FROM ADDRESS3;

SELECT c.CUSTOMER_ID , c.FIRST_NAME , c.LAST_NAME , a.ADDRESS , a.PHONE 
FROM CUSTOMER c
INNER JOIN ADDRESS3 a ON c.ADDRESS_ID = a.ADDRESS_ID;


SELECT c.COUNTRY_NAME , l.CITY 
FROM LOCATIONS l
INNER JOIN COUNTRIES c ON l.COUNTRY_ID = c.COUNTRY_ID;


---LEFT AND RIGHT OUTER JOIN

--LEFT OUTER JOIN: returns the matching data from both table and non-matching from the left table
SELECT c.CUSTOMER_ID, c.FIRST_NAME, c.LAST_NAME, a.ADDRESS, a.PHONE
FROM CUSTOMER c
LEFT OUTER JOIN ADDRESS a ON c.ADDRESS_ID = a.ADDRESS_ID;

---RETURNING ONLY NON-MATCHING PART FROM THE LEFT TABLE USING WHERE CLAUSE

SELECT c.CUSTOMER_ID, c.FIRST_NAME, c.LAST_NAME, a.ADDRESS, a.PHONE
FROM CUSTOMER c
LEFT OUTER JOIN ADDRESS a ON c.ADDRESS_ID = a.ADDRESS_ID
WHERE a.ADDRESS_ID IS NULL;


--RIGHT OUTER JOIN: returns the matching data from both table and non-matching from the right table
SELECT c.CUSTOMER_ID, c.FIRST_NAME, c.LAST_NAME, a.ADDRESS, a.PHONE
FROM CUSTOMER c
RIGHT OUTER JOIN ADDRESS a ON c.ADDRESS_ID = a.ADDRESS_ID;

---RETURNING ONLY NON-MATCHING PART FROM THE RIGHT TABLE USING WHERE CLAUSE

SELECT c.CUSTOMER_ID, c.FIRST_NAME, c.LAST_NAME, a.ADDRESS, a.PHONE
FROM CUSTOMER c
RIGHT OUTER JOIN ADDRESS a ON c.ADDRESS_ID = a.ADDRESS_ID
WHERE c.ADDRESS_ID IS NULL;


--FULL OUTER JOIN: displays matching data from both talbes, non-matching data from right table and non-matching data from left table

SELECT * 
FROM CUSTOMER c
FULL OUTER JOIN ADDRESS3 a ON c.ADDRESS_ID = a.ADDRESS_ID;

SELECT c.CUSTOMER_ID,   c.FIRST_NAME,   c.LAST_NAME,   a.ADDRESS,   a.PHONE 
FROM CUSTOMER c
FULL OUTER JOIN ADDRESS3 a ON c.ADDRESS_ID = a.ADDRESS_ID;

--RETURNING NON-MATCHING DATA FROM BOTH TABLES USING WHERE CLAUSE
SELECT *
FROM CUSTOMER c
FULL OUTER JOIN ADDRESS3 a ON c.ADDRESS_ID = a.ADDRESS_ID
WHERE a.ADDRESS_ID IS NULL OR c.ADDRESS_ID IS NULL;

/*
SELF JOIN: joining the table to itself/comparing columns within the same table
        syntax: 
                SELECT COLUMNS FROM TABLE1 a JOIN TABLE1 b ON a.KEY = b.KEY
 */       

SELECT EMPLOYEE_ID, FIRST_NAME , LAST_NAME , MANAGER_ID
FROM EMPLOYEES;

SELECT e1.EMPLOYEE_ID , e1.FIRST_NAME , e2.LAST_NAME , e1.MANAGER_ID, e2.FIRST_NAME ||' '|| e2.LAST_NAME  AS "FULL NAME"
FROM EMPLOYEES e1
JOIN EMPLOYEES e2 ON e1.MANAGER_ID = e2.EMPLOYEE_ID;

SELECT e2.FIRST_NAME ||' '|| e2.LAST_NAME  AS "MANAGER FULL NAME" , COUNT(*)
FROM EMPLOYEES e1
JOIN EMPLOYEES e2 ON e1.MANAGER_ID = e2.EMPLOYEE_ID
GROUP BY  e2.FIRST_NAME ||' '|| e2.LAST_NAME ;

---SET OPERATORS
--UNION & UNION ALL
SELECT * FROM DEVELOPERS
UNION
SELECT * FROM TESTERS;

SELECT NAMES FROM DEVELOPERS
UNION
SELECT NAMES FROM TESTERS;
--REMOVES THE DUPLICATED ROWS, SORTS IN ASCENDING ORDER


SELECT NAMES FROM DEVELOPERS
UNION ALL
SELECT NAMES FROM TESTERS;
--DOES NOT REMOVE DUPLICATES, AND DOES NOT SORT


--MINUS: 

SELECT NAMES FROM DEVELOPERS
MINUS
SELECT NAMES FROM TESTERS;
--RETURNS THE 1 QUERIE'S ROWS THAT ARE NOT MATCHING WITH 2ND QUERY'S ROWS

--INTERSECT:

SELECT NAMES FROM DEVELOPERS
INTERSECT
SELECT NAMES FROM TESTERS;
--RETURNS THE MATCHING ROWS FROM 2 QUERIES